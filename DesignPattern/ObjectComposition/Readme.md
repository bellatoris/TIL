# Object Composition
상속의 경우 부모 클래스의 구현이 서브 클래스에 다 드러나는 것이기 때문에 상속은 
캡슐화를 파괴한다고 볼 수 있다. 그래서 서브클래스는 부모 클래스의 구현에
종속되고, 부모 클래스 구현에 변경이 생기면 서브 클래스도 변경해야 한다.

객체 합성은 객체가 다른 객체에 대한 참조자를 얻는 방식으로 
런타임 시에 동적으로 이루어진다. 합성은 객체가 다른 객체의 인터페이스만을 
바라보게 한다. 이로써 객체의 인터페이스 정의에 보다 많은 주의를 기울여야 한다. 
객체는 인터페이스를 통해서만 접근하므로 캡슐화를 유지할 수 있다. 객체가 동일한 
타입을 갖는다면 다른 객체로 런타임 시에 대체가 가능하다. 객체의 구현은 
인터페이스에 맞추어 이루어지므로 구현 간의 종속은 확실히 줄어든다.

객체 합성은 각 클래스의 캡슐화를 유지할 수 있기 때문에, 클래스 계층이 소규모로 
유지돼 통제 불능의 괴물 같이 큰 계층도가 만들어지는 것을 막아준다.

```python
class Gun:
    def bang(self):
        print("빵야!")


class PoliceMan:
    def __init__(self, gun=None):
        self.__gun = gun

    def shoot(self):
        if self.__gun:
            self.__gun.bang()
        else:
            print("총이 없다..")
```
