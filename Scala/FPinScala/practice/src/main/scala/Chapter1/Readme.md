# 제1장 함수형 프로그래밍이란 무엇인가?

FP 란 순수 함수들로 프로그래밍 하는 것이며, 순수함수는 효과가 없는 함수이다. 함수는 
주어진 입력으로 뭔가를 계산하는 것 외에는 프로그램의 실행에 그 어떤 관찰 가능한 영향도 
미치지 않는다. 순수 함수의 이러한 개념을 **참조 투명성** 이라는 개념을 이용해 공식화 할 
수 있다.

**참조 투명성과 순수성**

> 만일 모든 프로그램 `p` 에 대해 표현식 `e` 의 모든 출현을 `e` 의 평가 결과로 치환해도 `p` 의 
의미에 아무 영향이 미치지 않는다면, 그 표현식 `e` 는 **참조에 투명하다**. 만일 표현식 
`f(x)` 가 참조에 투명한 모든 `x` 에 대해 참조에 투명하면, 함수 `f` 는 **순수하다**.

부수효과가 필요한 경우, 부수 효과가 발생하기 하지만 **관찰되지는 않도록** 코도의 구조를 
짜야한다. 

## 1.3 참조 투명성, 순수성, 그리고 치환 모형

```scala
def buyCoffee(cc: CreditCard): Coffee = {
    val cup = new Coffee()
    cc.charge(cup.price)
    cup
}
```

`buyCoffee` 는 `cc.charge(cup.price)` 의 반환값을 폐기한다. 따라서 `buyCoffee` 의 평가 결과는 
그냥 `cup` 이며, 이는 `new Coffee()` 와 동등한다. 앞의 참조 투명성 정의하에서 `buyCoffee` 가 
순수하려면 **임의의** `p`에 대해 `p(buyCoffee(aliceCreditCard))` 가 `p(new Coffee())` 와 
동일하게 작동해야 한다. 이 조건이 참이 아님은 명백하다.  
참조 투명성은 함수가 **수행하는** 모든 것이 함수가 돌려주는 **값**으로 대표된다는 불변 조건을 
강제한다. 이러한 제약을 지키면 **치환 모형**이라고 부르는, 프로그램 평가에 대한 간단하고도 
자연스러운 추론 모형이 가능해진다.  
순수 함수는 모듈적이고 함성 가능한데, 이는 순수 함수에서 계산 자체의 논리가 "결과로 무엇을 할 
것인가와" 나 "입력을 어떻게 얻을 것인가" 와는 분리되어 있기 때문이다. 이러한 관심사의 분리 
덕분에 계산 논리의 재사용성이 높아진다.

